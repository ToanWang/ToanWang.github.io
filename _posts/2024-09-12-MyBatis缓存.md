---
layout:     post
title:      MyBatis缓存学习
subtitle:   MyBatis
date:       2024-09-12
author:     toan
catalog:	true
tags:
    - cache
    - MyBatis
---



# 参考资料

[美团技术MyBatis](https://tech.meituan.com/2018/01/19/mybatis-cache.html)

# 问题背景

新到公司接了一个小需求，需要给某个列表查询增加一个字段，同时看看能不能优化一下之前的代码

1. 想到的最简单的优化手段，减少查表次数，按照任务id分组查出来所需的全部信息
2. 改完之后接口耗时对比为 `227 : 174`
3. 为了验证是不是偶现的提高，把这个接口循环执行了十次，改完的接口普遍会快一点，第十次结果对比为 `95.7 : 39.5`

此时有个疑问，为什么接口耗时越来越少，评审时问了组长，他只说了句数据库有缓存，但是之前了解到的是`MySQL`是去掉了结果缓存。由于太久没写`Java`了，不确定是不是`MyBatis`框架也有类似的缓存，因为时间紧，就没继续问下去，后面有时间验证一下

# 验证

## sql1查询耗时

主要进行以下操作，结果如下

1. 单个`sql`执行三次，记录耗时
2. 接口执行十次，计算耗时

```text
time_cost, func_first_select 13
time_cost, func_second_select 13
time_cost, func_third_select 11
once_func_cost 187
===================================
time_cost, func_first_select 17
time_cost, func_second_select 13
time_cost, func_third_select 14
once_func_cost 70
```

## 代码分段验证

分别统计了四个地方的耗时：`sql1`、`sql2`、`stream`操作、返回对象构造，耗时如下

```
step_1_cost 119
step_2_cost 27
step_3_cost 0
step_4_cost 0
once_func_cost 147
====================================
step_1_cost 15
step_2_cost 16
step_3_cost 0
step_4_cost 0
once_func_cost 31
```

## sql2查询耗时

主要进行以下操作，结果如下

1. 单个`sql`执行三次，记录耗时
2. 接口执行十次，计算耗时

```
first_cost 205
second_cost 166
third_cost 41
once_func_cost 678
====================================
first_cost 169
second_cost 32
third_cost 152
once_func_cost 512
====================================
first_cost 147
second_cost 23
third_cost 25
once_func_cost 232
```

# 现象

1. 第一个`sql`查询，同一个语句，重复查询三次，都打印了`sql` ，并且耗时接近
   1. 十次结果中，后面九次时间都比较接近，说明还是有地方有优化

2. 然后打印了不同代码块的耗时，发现还是`sql`耗时有变化，重新统计了另一个`sql`的耗时

3. 第二个`sql`查询，第二次查询耗时明显降低，但是还是打印了`sql`

其他信息

3. 第二个`sql`是先于第一个执行的
4. 项目使用的是`pgsql`

# 小结

1. 项目使用的是`pgsql`，不支持强制使用结果缓存，肯定不是命中了数据库的查询缓存结果
2. 同一个`sql` 执行多次，每次耗时相同，说明也没有用到`MyBatis`的一级缓存
   1. 一级缓存是即时生效的
   2. 并且每次都打印了`sql`，侧面印证没有用到一级缓存（这个不确定在哪里可以配置）
   3. 在一个`sql`第二次执行之间，更新了当前数据（目的是为了使一级缓存失效），但是第二次耗时和之前类似，侧面印证没有用到一级缓存
3. 对比数据发现，同一个`sql`内第二次执行耗时缩短约100毫秒。接口连续多次执行，第二耗时缩短也在100毫秒
   1. 可以猜测是第一个建立连接会耗时

