---
layout:     post
title:      分布式事务一致性
subtitle:   分布式事务
date:       2024-09-19
author:     toan
catalog:	true
tags:
    - 分布式事务
---

主要看了小米的这篇文章，觉得写的很清晰 [小米技术团队-分布式事务](https://xiaomi-info.github.io/2020/01/02/distributed-transaction/)

## 个人理解

看完一些文章之后的愚见，分布式事务需要实现下面几点

1. 事务传递：需要一个`MQ`存储`A服务`成功的事务数据，`B服务`消费`MQ`中的数据，实现分布式事务的传递
2. 事务一致性：需要额外的机制保证 `A服务`消费了但是`B服务`还没消费的数据 和 `MQ`中的数据保持一致【拆分成两个小问题：补偿`A服务`事务写`MQ`丢失；补偿`B服务`消费`MQ`异常】
   * 采用本地消息表：
     * 数据消费和本地消息表写入在一个事务中【保证`A服务`消费的数据肯定在消息表中，如果写`MQ`失败了，后面轮训会补偿】
     * 轮训消息表，将`B事务`没消费的数据，提交到`MQ`中【补偿`B服务`消费数据异常】
   * `MQ`自身保证：
     * `A服务`执行数据之前，保证先把一个`prepare`消息写到`MQ`【保证`A服务`执行的事务不会在丢失在写`MQ`这个步骤，如果丢了，后面轮训会补偿】
     * `MQ`自身轮训`prepare`消息 和 `A服务`本身不一致的数据，重新写入`MQ`或者直接回滚【补偿`B服务`消费数据异常】
3. 接口的幂等设计：重复消费不会出问题【主要是`B服务`消费之后通知`A服务`失败，可能导致重复消费】

## 两阶段提交

[支付宝-两阶段提交](https://antdigital.com/docs/11/132929)

<img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/2938582161/p231073.png" alt="2PC" style="zoom:50%;" />



1. 一阶段：协调者询问所有参与者，是否为`ready`状态【可以执行事务】
2. 二阶段：如果可以执行，全部提交事务；如果不可以，全部回滚

部分问题解决措施

1. 持久化状态：参与者状态和事务执行结果会被持久化存储，保证在系统故障时可以恢复
2. 超时处理：如果有参与者没有正确响应，会进行重试或者回滚
3. 补偿机制：参考`TCC`，具体实现不明确

## TCC

`try-confirm-cancel`

* `try`：尝试执行，进行业务检查，预留业务资源
* `confirm`：真正执行事务，只使用上一阶段预留的业务资源
* `cancel`：取消执行，释放业务资源

### 本地消息表

<img src="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/native-message.jpg" alt="img" style="zoom:50%;" />

本地消息表的示意图

1. `A服务`：收到一条变更数据，执行下面两个操作
   * 事务操作：写业务数据和写消息数据【写到本地消息表】，保证`A服务`中业务处理的数据，一定会写到本地消息表
   * `A服务`同时有**定时任务**在本地消息表中查询没有被处理的消息，加到`Kafka`里面【保证 业务数据中没有被`B服务`处理的数据，一定在`Kafka`中存在】
2. `B服务`：从`Kafka`中消费数据，从`Kafka`读消息，进行业务操作【消费`kafka`消息可以异步执行，直到把数据全部消费掉】
   * 业务操作失败：通知`A服务`进行回滚【补偿逻辑】
   * 服务出现异常：`Kafka`中一定还有这次数据，后面继续消费即可

### 可靠消息最终一致性

<img src="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/mq-message.jpg" alt="img" style="zoom:50%;" />

主要分为以下步骤

1. `A服务操作`
   * 发送`prepare`消息，如果失败，取消操作；如果成功，执行下一步
   * 本地执行事务，发送`confirm`消息，如果失败，回滚事务
2. `B服务操作`
   * 定时消费`MQ`中的数据，如果是业务失败，会向`A服务`发起回滚请求；如果事务失败，会重复消费
   * 执行成功，发送确认消息
3. `MQ操作`
   * **定期轮训**所有的`prepare`消息，如果对应的消息在`A服务`执行成功，继续发送`confirm`消息到`NQ`；否则进行回滚

和本地消息表区别

1. 去掉了本地消息表
2. 本地消息表依赖定时轮训本地消息，来处理`A服务`中和`MQ`不一致的数据；此方案依靠`MQ`内部的轮训机制来实现，只有阿里`ROcketMQ`支持
